n, a, b = map(int, input().split())

dp = [10000000] * (n + 5)

dp[0] = 0

for i in range(2, n + 5):
    if i >= 2:
        dp[i] = min(dp[i], dp[i - 2] + a)
    if i >= 5:
        dp[i] = min(dp[i], dp[i - 5] + b)

print(min(dp[n:]))


"""
まず、dp[n] をちょうど n 個のりんごを買うのに必要な金額の最小値とすると、dp[0] ~ dp[k-1] と dp[k] の関係は dp[k] = min(dp[k-2] + a, dp[k-5] + b) となります。
まずはこの漸化式に従って dp を小さい方から順に計算しましょう。
このままでは、2と5の組合せで作れない個数について、答えを正しく計算することができません。
そこで、この dp を利用してちょうど n 個ではなく、n 個以上のりんごを買うのに必要な金額の最小値を求めることを考えます。
dp2[n] を n 個以上のりんごを買うのに必要な金額の最小値とすると、定義から dp2[n] = min(dp[n], dp[n+1], ...) であることがわかります。
dp2[n] が問題の答えです。
ループの回し方を工夫して配列 dp をうまく書き換えると、わざわざ dp2 のような配列を新しく作らなくても答えを求めることができます。
具体的には、dp2[n] = min(dp[n], dp[n+1], ...) = min(dp[n], dp2[n+1]) であることに注目し、
dpを添字が大きい方から dp[k] = min(dp[k], dp[k+1]) のように書き換えていけば、dp[n] が n 個以上のりんごを買うのに必要な金額の最小値となります。
このとき、dp[k]を書き換えた時点では、dp[i (< k) ] はちょうど i 個のりんごを買うのに必要な金額の最小値に、
dp[i (≧ k) ] は i 個以上のりんごを買うのに必要な金額の最小値 (=dp2[i]) になっています。
n 個のりんごを最も安く手に入れたいときに n+5 個以上のりんごを買うのは無駄ですから、dp は dp[n+4] 程度まで計算しておけば十分です。
実は a < b であることから dp[n+2] まで計算しておけば十分であることがわかるのですが、そこまで切り詰める必要はありません。
"""